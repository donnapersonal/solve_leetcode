# 31.Next Permutation

## LeetCode 题目链接

[31.下一个排列](https://leetcode.cn/problems/next-permutation/)

## 题目大意

整数数组的一个排列 就是将其所有成员以序列或线性顺序排列

例如，`arr = [1,2,3]`，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]`

整数数组的`下一个排列`是指其整数的下一个字典序更大的排列。更正式地，若数组的所有排列根据其字典顺序从小到大排列在一个容器中，则数组的下一个排列就是在这个有序容器中排在它后面的那个排列；如果不存在下一个更大的排列，则这个数组必须重排为字典序最小的排列（即，其元素按升序排列）
- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]`
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]`
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]`，因为 `[3,2,1]` 不存在一个字典序更大的排列

给一个整数数组 `nums`，找出 `nums` 的下一个排列

必须`原地`修改，只允许使用额外常数空间

```js
Example 1:
Input: nums = [1,2,3]
Output: [1,3,2]

Example 2:
Input: nums = [3,2,1]
Output: [1,2,3]

Example 3:
Input: nums = [1,1,5]
Output: [1,5,1]
```

限制:
- 1 <= nums.length <= 100
- 0 <= nums[i] <= 100

## 解题

核心思想：利用字典序的规律，找到调整的最小必要部分，保证调整后的排列是下一个最小的字典序排列
- 利用字典序规则，从右往左找到调整点，做局部交换和反转，使得排列变大但尽可能小

为什么找递减点？
- 若从右往左整个数组是递增的（即从左往右是降序排列），说明当前排列是字典序最大的排列，如 `[5, 4, 3, 2, 1]`
- 此时需将整个数组反转，返回字典序最小的排列（升序排列）
- 若存在递减点 `i`，说明可以通过交换 `nums[i]` 和某个更大的数字，使整体排列变得更大

递减点是指数组中从右向左遍历时，第一个满足：`nums[i] < nums[i+1]` 的位置 `i`

找到第一个递减点可以帮助找到调整的起点：
- 从右向左找到第一个满足 `nums[i] < nums[i+1]` 的位置 `i`，说明从 `i+1` 到数组末尾的部分是降序排列

递减点是从右向左遍历找到的第一个 `nums[i] < nums[i+1]` 的位置：
- 若没有递减点，说明当前排列是字典序最大排列，直接反转整个数组，返回最小排列
- 若找到递减点，意味着右侧部分可以重新排列，通过交换和反转生成下一个排列

```js
var nextPermutation = function(nums) {
    const n = nums.length;
    // 从右往左找到第一个递减的位置
    let i = n - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    if (i >= 0) {
        // 从右往左找到第一个比 nums[i] 大的数字
        let j = n - 1;
        while (nums[j] <= nums[i]) {
            j--;
        }
        // 交换 nums[i] 和 nums[j]
        [nums[i], nums[j]] = [nums[j], nums[i]];
    }

    // 反转 i 之后的部分
    let left = i + 1;
    let right = n - 1;
    while (left < right) {
        [nums[left], nums[right]] = [nums[right], nums[left]];
        left++;
        right--;
    }
};
```
```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        n = len(nums)
        # 从右往左找到第一个递减的位置
        # 从数组的倒数第二个元素开始检查（因为需比较 nums[i] 和 nums[i+1]）
        i = n - 2
        while i >= 0 and nums[i] >= nums[i + 1]:
            i -= 1
        
        # 为什么找这个元素？
        # 因为如果从右到左一直是升序，则当前排列已经是字典序的最大排列，例如：[3, 2, 1]
        # 需从这个「交换点」开始调整才能得到下一个更大的排列
        # 如果找到了这个元素，则继续处理
        if i >= 0:
            # 从右往左找到第一个比 nums[i] 大的数字
            # 为什么找比 nums[i] 大的最小元素 -- 为了让新的排列尽可能接近当前排列（尽量小），从而保证是「下一个」字典序排列
            j = n - 1
            while nums[j] <= nums[i]:
                j -= 1
            
            # 交换 nums[i] 和 nums[j]
            # nums[j] > nums[i]，交换后左侧部分保持尽可能小的排列，右侧部分会被重新排列
            nums[i], nums[j] = nums[j], nums[i]
        
        # 将 nums[i+1:] 的部分反转，即反转 i 之后的部分
        # nums[i+1:] 的部分在原数组中是降序排列，而字典序要求最小的排列是升序排列，将其反转后变成升序排列
        # 反转后保证了整体排列的字典序最小化
        left, right = i + 1, n - 1
        while left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
```

- 时间复杂度：`O(n)`，其中 `n` 是数组的长度
  - 找递减点的复杂度：`(n)`
  - 找比 `nums[i]` 大的最小数字的复杂度：`O(n)`
  - 反转后半部分的复杂度：`O(n)`
- 空间复杂度：`O(1)`，因为只使用了常数空间来存储变量，没有使用额外的空间