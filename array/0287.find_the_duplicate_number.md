# 287.Find the Duplicate Number

## LeetCode 题目链接

[287.寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

## 题目大意

给定一个包含 `n + 1` 个整数的数组 `nums`，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数

假设 `nums` 只有一个重复的整数 ，返回这个重复的数 

设计的解决方案必须`不修改`数组 `nums` 且只用常量级 `O(1)` 的额外空间

```js
Example 1:
Input: nums = [1,3,4,2,2]
Output: 2

Example 2:
Input: nums = [3,1,3,4,2]
Output: 3

Example 3:
Input: nums = [3,3,3,3,3]
Output: 3
```

限制：
- 1 <= n <= 10^5
- nums.length == n + 1
- 1 <= nums[i] <= n
- All the integers in nums appear only once except for precisely one integer which appears two or more times.

## 解题

### 思路 1: 快慢指针

题目要求在不修改数组的前提下，且使用 `O(1)` 的额外空间来寻找重复的整数。对于这类寻找重复数的题目，可使用`快慢指针法`（`Floyd 判圈算法`） 来解决

该方法通常用于链表中检测环的存在。在这道题目中，由于所有数字都在 `[1, n]` 范围内，可以将每个数字看作链表中的一个节点，将值 `nums[i]` 看作链表的下一个指针 `next`，即 `nums[i]` 指向 `nums[nums[i]]`

定义快慢指针：
- 使用 `slow` 和 `fast` 两个指针，从数组的第一个元素 `nums[0]` 开始，分别代表慢指针和快指针
- `slow` 每次移动一步：`slow = nums[slow]`
- `fast` 每次移动两步：`fast = nums[nums[fast]]`

找到相遇点：
- 由于数组中有重复的数字，意味着从 `nums[0]` 开始的链表中一定会形成一个环
- 当 `slow` 和 `fast` 相遇时，可以确定链表中存在环

找到环的入口：
- 令 `slow` 指针回到起点 `nums[0]`，`fast` 继续留在相遇点
- 两个指针每次都移动一步：`slow = nums[slow]`，`fast = nums[fast]`
- 当两个指针再次相遇时，相遇点即为环的入口，即数组中重复数字的位置

> 为什么这种方法有效？
> - 使用快慢指针检测环的思想应用在数组上，因为每个元素的值可以看作是指向下一个元素的指针
> - 在有重复元素的情况下，必然会形成一个环（因为会有两个或以上的元素指向同一个位置），而环的入口就是重复数字

```js
```
```python
```

### 思路 2: 二分查找