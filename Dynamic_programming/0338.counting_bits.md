# 338.Counting Bits

## LeetCode 题目链接

[338.比特位计数](https://leetcode.cn/problems/counting-bits/)

## 题目大意

给你一个整数 `n`，对于 `0 <= i <= n` 中的每个 `i`，计算其二进制表示中 `1` 的个数，返回一个长度为 `n + 1` 的数组 `ans` 作为答案

```js
Example 1:
Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10

Example 2:
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

限制:
- 0 <= n <= 10^5

## 解题

### 思路 1

根据整数的二进制特点可以将整数分为两类：
- 奇数：其二进制表示中 `1` 的个数一定比前面相邻的偶数多一个 `1`
- 偶数：其二进制表示中 `1` 的个数一定与该数除以 `2` 之后的数一样多·
- 另外，边界 `0` 的二进制表示中 `1` 的个数为 `0`

于是可以根据规律，从 `0` 开始到 `n` 进行递推求解

定义状态 `dp[i]` 表示为：整数 `i` 对应二进制表示中 `1` 的个数

- 如果 `i` 为奇数，则整数 `i` 对应二进制表示中 `1` 的个数等于整数 `i-1` 对应二进制表示中 `1` 的个数加 `1`，即 `dp[i] = dp[i-1] + 1`
- 如果 `i` 为偶数，则整数 `i` 对应二进制表示中 `1` 的个数等于整数 `i / 2` 对应二进制表示中 `1` 的个数，即 `dp[i] = dp[i / 2]`

初始条件：整数 `0` 对应二进制表示中 `1` 的个数为 `0`

```js
var countBits = function(n) {
    let dp = new Array(n + 1).fill(0); // 初始化一个长度为 n+1 的数组，所有元素为 0
    for (let i = 1; i <= n; i++) {
        if (i % 2 === 1) { // 判断 i 是否为奇数
            dp[i] = dp[i - 1] + 1; // 奇数的 1 的个数等于前一个偶数的 1 的个数加 1
        } else {
            dp[i] = dp[i / 2]; // 偶数的 1 的个数等于它除以 2 后的 1 的个数
        }
    }
    return dp;
};
```
```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0 for _ in range(n+1)]
        # 遍历从 1 到 n 的每一个整数 i
        for i in range(1, n + 1):
            # 对于奇数 i，其二进制表示的 1 的个数等于前一个偶数 i - 1 的 1 的个数再加 1
            # 如：3 (二进制 11) 的 1 的个数等于 2 (二进制 10) 的 1 的个数加 1
            if i % 2 == 1:
                dp[i] = dp[i - 1] + 1
            else:
                # 对于偶数 i，其二进制表示的 1 的个数等于 i 除以 2 后的 1 的个数
                # 因为偶数 i 的二进制表示是 i / 2 的二进制表示的所有位向左移一位，最低位变为 0，因此 1 的个数不变
                # 4 (二进制 100) 的 1 的个数等于 2 (二进制 10) 的 1 的个数
                dp[i] = dp[i // 2]
        return dp
```

- 时间复杂度：`O(n)`，代码初始化了一个长度为 `n + 1` 的数组，并遍历了 `1` 到 `n` 的所有整数
- 空间复杂度：`O(n)`，代码使用了一个长度为 `n + 1` 的数组来存储结果

### 思路 2

对于任何整数 `i`，可以将其看作是 `i/2`（`i >> 1`，右移一位）加上 `i` 的最低位（`i & 1` -> `0 或 1`），避免了重复计算，节省了计算时间

例子：
```js
i = 5，二进制为 101：
- i >> 1 = 2，二进制为 10
- dp[2] = 1（2 的二进制表示 10 中有一个 1）
- i & 1 = 1（5 的最低位是 1）
- dp[5] = dp[2] + 1 = 1 + 1 = 2
```

```js
var countBits = function(n) {
    const dp = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        dp[i] = dp[i >> 1] + (i & 1);
    }
    return dp; 
};
```
```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        ans = [0] * (n + 1)
        for i in range(1, n + 1):
            # i >> 1：表示将 i 右移一位，即 i 除以 2 取整（去掉 i 的最低位）
            # dp[i >> 1] 表示去掉 i 的最低位后，剩余部分的 1 的个数

            # i & 1：表示 i 的最低位是 0 还是 1
            # 如果 i & 1 == 1，说明 i 的最低位是 1
            # 如果 i & 1 == 0，说明 i 的最低位是 0
            ans[i] = ans[i >> 1] + (i & 1)
        return ans
```

- 时间复杂度分析：`O(n)`
  - 只遍历了一次从 `1` 到 `n` 的所有数字
  - 每次迭代中的操作（位运算和数组访问）都是 `O(1)`
- 空间复杂度：`O(1)`，除了返回的数组以外，空间复杂度为常数