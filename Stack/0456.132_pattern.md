# 456.132 Pattern

## LeetCode 题目链接

[456.132 模式](https://leetcode.cn/problems/132-pattern/)

## 题目大意

给你一个整数数组 `nums`，数组中共有 `n` 个整数。`132` 模式的子序列由三个整数 `nums[i]`、`nums[j]` 和 `nums[k]` 组成，并同时满足：`i < j < k` 和 `nums[i] < nums[k] < nums[j]` 

如果 `nums` 中存在 `132` 模式的子序列 ，返回 `true`；否则，返回 `false`

```js
Example 1:
Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.

Example 2:
Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].

Example 3:
Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
```

限制:
- n == nums.length
- 1 <= n <= 2 * 105
- -10^9 <= nums[i] <= 10^9

## 解题

### 思路 1: 单调栈

此处使用 `倒序遍历 + 单调栈`

核心思路：
- 固定 `j`，然后寻找比 `nums[j]` 小但比某个更小值大的 `nums[k]`
- 从右向左遍历数组：
  - 把候选的 `nums[k]` 存进一个单调递减栈
  - 同时维护一个变量 `second`（表示满足条件的最大 `nums[k]`）

```js
var find132pattern = function(nums) {
    let stack = [], second = -Infinity;

    for (let i = nums.length - 1; i >= 0; i--) {
        if (nums[i] < second) return true;
        while (stack.length && nums[i] > stack[stack.length - 1]) {
            second = stack.pop();
        }
        stack.push(nums[i]);
    }

    return false;
};
```
```python
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        stack = []
        second = float('-inf')  # 记录 potential nums[k]

        for i in range(len(nums) - 1, -1, -1):
            if nums[i] < second:
                return True  # 找到满足 nums[i] < second < nums[j]
            while stack and nums[i] > stack[-1]:
                second = stack.pop()
            stack.append(nums[i])

        return False
```

- 时间复杂度：`O(n)`，枚举 `i` 的次数为 `O(n)`，由于每个元素最多被加入和弹出单调栈各一次，因此操作单调栈的时间复杂度一共为 `O(n)`，总时间复杂度为 `O(n)`
- 空间复杂度：`O(n)`，即为单调栈需要使用的空间

### 思路 2

思路 1 是从后向前遍历的，本质上需要提前知道整个数组

而思路 2 是从前向后遍历的，且维护的数据结构不依赖于后续未知的元素，因若数组是以「数据流」的形式给出的，则下面是唯一可继续使用的方法

```python
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        num_i, num_j = [-nums[0]], [-nums[0]]
        for num in nums[1:]:
            idx_i = bisect.bisect_right(num_i, -num)
            idx_j = bisect.bisect_left(num_j, -num)

            if idx_i < idx_j:
                return True
            
            if num < -num_i[-1]:
                num_i.append(-num)
                num_j.append(-num)
            elif num > -num_j[-1]:
                last_i = -num_i[-1]
                while num_j and num > -num_j[-1]:
                    num_i.pop()
                    num_j.pop()
                num_i.append(-last_i)
                num_j.append(-num)

        return False
```

- 时间复杂度：`O(nlogn)`
  - 枚举 `i` 的次数为 `O(n)`，由于每一个元素最多被加入和弹出单调栈各一次，因此操作单调栈的时间复杂度一共为 `O(n)`
  - 二分查找的单次时间为 `O(logn)`，一共为 `O(nlogn)`，总时间复杂度为 `O(nlogn)`
- 空间复杂度：`O(n)`，即为单调栈需要使用的空间