# 443.String Compression

## LeetCode 题目链接

[443.压缩字符串](https://leetcode.cn/problems/string-compression/)

## 题目大意

给你一个字符数组 `chars`，请使用下述算法压缩：

从一个空字符串 `s` 开始。对于 `chars` 中的每组 连续重复字符 ：
- 如果这一组长度为 `1`，则将字符追加到 `s` 中
- 否则，需向 `s` 追加字符，后跟这一组的长度
  
压缩后得到的字符串 `s` 不应该直接返回，需转储到字符数组 `chars` 中。注意：如果组长度为 `10` 或 `10` 以上，则在 `chars` 数组中会被拆分为多个字符

请在修改完输入数组后，返回该数组的新长度

你必须设计并实现一个只使用常量额外空间的算法来解决此问题

```js
Example 1:
Input: chars = ["a","a","b","b","c","c","c"]
Output: Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
Explanation: The groups are "aa", "bb", and "ccc". This compresses to "a2b2c3".

Example 2:
Input: chars = ["a"]
Output: Return 1, and the first character of the input array should be: ["a"]
Explanation: The only group is "a", which remains uncompressed since it's a single character.

Example 3:
Input: chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
Output: Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
Explanation: The groups are "a" and "bbbbbbbbbbbb". This compresses to "ab12".
```

限制：
- 1 <= chars.length <= 2000
- chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.

## 解题

为了实现原地压缩，可以使用双指针分别标志我们在字符串中读和写的位置。每次当读指针 `read` 移动到某一段连续相同子串的最右侧，就在写指针 `write` 处依次写入该子串对应的字符和子串长度即可

使用两个指针：
- `read`：当前读取到的位置
- `write`：当前写入字符的位置
- `left`：当前连续字符的开始位置

流程：
- 遍历数组
- 如果到最后一个字符，或当前字符 `≠` 下一个字符：
  - 把当前字符写入到 `write`
  - 如果当前组长度 > 1，把长度（转为字符串）逐个写入
- 返回最终的 `write` 位置即为长度

```js
var compress = function(chars) {
    let write = 0, left = 0;

    for (let read = 0; read < chars.length; read++) {
        if (read + 1 === chars.length || chars[read] !== chars[read + 1]) {
            chars[write++] = chars[left];
            const count = read - left + 1;

            if (count > 1) {
                const digits = String(count);
                for (let ch of digits) {
                    chars[write++] = ch;
                }
            }

            left = read + 1;
        }
    }

    return write;
};
```
```python
class Solution:
    def compress(self, chars: List[str]) -> int:
        write = 0
        left = 0 

        for read in range(len(chars)):
            if read + 1 == len(chars) or chars[read] != chars[read + 1]:
                chars[write] = chars[left]
                write += 1

                count = read - left + 1
                if count > 1:
                    for digit in str(count):
                        chars[write] = digit
                        write += 1

                left = read + 1 
        
        return write
```

- 时间复杂度：`O(n)`，其中 `n` 为字符串长度，只需遍历该字符串一次
- 空间复杂度：`O(1)`，只需常数的空间保存若干变量