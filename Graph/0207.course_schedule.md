# 207.Course Schedule

## LeetCode 题目链接

[207.课程表](https://leetcode.cn/problems/course-schedule/)

## 题目大意

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 

在选修某些课程之前需要一些先修课程，先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [a_i, b_i]`，表示如果要学习课程 `a_i` 则必须先学习课程  `b_i`
- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0`，需完成课程 `1` 
  
请判断是否可能完成所有课程的学习？如果可以，返回 `true`；否则，返回 `false` 

```js
Example 1:
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.

Example 2:
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
```

限制：
- 1 <= numCourses <= 2000
- 0 <= prerequisites.length <= 5000
- prerequisites[i].length == 2
- 0 <= a_i, b_i < numCourses
- All the pairs prerequisites[i] are unique.

## 解题

此题可以使用`拓扑排序`的方法来解决

### 思路 1: DFS 实现

```js
// 写法 1
var canFinish = function(numCourses, prerequisites) {
    // 创建邻接表表示图
    const graph = Array.from({ length: numCourses }, () => []);
    for (const [course, prereq] of prerequisites) {
        graph[course].push(prereq);
    }

    // 记录每个节点的访问状态
    // 0: 未访问, 1: 正在访问, 2: 已完成访问
    const visited = new Array(numCourses).fill(0);

    const dfs = (course) => {
        // 如果当前课程正在被访问，说明存在环
        if (visited[course] === 1) return false;

        // 如果当前课程已经被访问过，直接返回true
        if (visited[course] === 2) return true;
        
        // 标记当前课程为正在访问
        visited[course] = 1;
        
        // 访问所有先修课程
        for (const prereq of graph[course]) {
            if (!dfs(prereq)) return false;
        }
        
        // 标记当前课程为已完成访问
        visited[course] = 2;
        return true;
    };

    // 对每个未访问的课程进行DFS
    for (let course = 0; course < numCourses; course++) {
        if (!dfs(course)) return false;
    }
    
    return true;
};

// 写法 2
var canFinish = function(numCourses, prerequisites) {
    const traverse = function(graph, s) {
        // 出现环
        if (onPath[s]) hasCycle = true;
        // 如果已经找到了环，也不用再遍历了
        if (visited[s] || hasCycle) return;
        // 前序代码位置
        visited[s] = true;
        onPath[s] = true;

        for (let t of graph[s]) {
            traverse(graph, t);
        }
        // 后序代码位置
        onPath[s] = false;
    };

    // 记录一次 traverse 递归经过的节点
    let onPath = new Array(numCourses).fill(false);
    // 记录遍历过的节点，防止走回头路
    let visited = new Array(numCourses).fill(false);
    // 记录图中是否有环
    let hasCycle = false;
    let graph = buildGraph(numCourses, prerequisites);

    for (let i = 0; i < numCourses; i++) {
        // 遍历图中的所有节点
        traverse(graph, i);
    }
    // 只要没有循环依赖可以完成所有课程
    return !hasCycle;
};

var buildGraph = function(numCourses, prerequisites) {
    // 图中共有 numCourses 个节点
    let graph = new Array(numCourses).fill(0).map(() => []);
    for (let edge of prerequisites) {
        let from = edge[1];
        let to = edge[0];
        // 修完课程 from 才能修课程 to
        // 在图中添加一条从 from 指向 to 的有向边
        graph[from].push(to);
    }
    return graph;
};
```
```python
# 写法 1
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # 创建邻接表表示图
        graph = [[] for _ in range(numCourses)]
        for course, prereq in prerequisites:
            graph[course].append(prereq)
        
        # 记录每个节点的访问状态
        # 0: 未访问, 1: 正在访问, 2: 已完成访问
        visited = [0] * numCourses

        def dfs(course):
            # 如果当前课程正在被访问，说明存在环
            if visited[course] == 1:
                return False
            # 如果当前课程已经被访问过，直接返回True
            if visited[course] == 2:
                return True
            
            # 标记当前课程为正在访问
            visited[course] = 1
            
            # 访问所有先修课程
            for prereq in graph[course]:
                if not dfs(prereq):
                    return False
            
            # 标记当前课程为已完成访问
            visited[course] = 2
            return True

        # 对每个未访问的课程进行DFS
        for course in range(numCourses):
            if not dfs(course):
                return False
        
        return True

# 写法 2
class Solution:
    def __init__(self):
        # 记录一次 traverse 递归经过的节点
        self.onPath = []
        # 记录遍历过的节点，防止走回头路
        self.visited = []
        # 记录图中是否有环
        self.hasCycle = False
    
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = self.buildGraph(numCourses, prerequisites)
        self.visited = [False] * numCourses
        self.onPath = [False] * numCourses

        for i in range(numCourses):
            # 遍历图中的所有节点
            self.traverse(graph, i)
        # 只要没有循环依赖可以完成所有课程
        return not self.hasCycle
    
    def traverse(self, graph: List[List[int]], s: int) -> None:
        if self.onPath[s]:
            # 出现环
            self.hasCycle = True 

        if self.visited[s] or self.hasCycle:
            # 如果已经找到了环，也不用再遍历了
            return
        
        # 前序代码位置
        self.visited[s] = True
        self.onPath[s] = True
        for t in graph[s]:
            self.traverse(graph, t)
        
        # 后序代码位置
        self.onPath[s] = False
    
    def buildGraph(self, numCourses: int, prerequisites: List[List[int]]) -> List[List[int]]:
        # 图中共有 numCourses 个节点
        graph = [[] for _ in range(numCourses)]
        for edge in prerequisites:
            from_node = edge[1]
            to_node = edge[0]
            # 修完课程 from 才能修课程 to
            # 在图中添加一条从 from 指向 to 的有向边
            graph[from_node].append(to_node)
        return graph
```

- 时间复杂度：`O(n + m)`，`n` 为课程数，`m` 为先修课程的要求数
- 空间复杂度：`O(n + m)`

### 思路 2: BFS 实现

```js
var canFinish = function(numCourses, prerequisites) {
    // 构建图
    const graph = new Map();
    for (let i = 0; i < numCourses; i++) {
        graph.set(i, []); // 初始化图中的每个节点为空列表
    }

    // 2. 构建邻接表表示的图
    for (let [v, u] of prerequisites) {
        graph.get(u).push(v); // u -> v 表示课程u依赖于课程v
    }

    // 3. 调用拓扑排序函数判断能否完成所有课程
    return topologicalSorting(numCourses, graph);
};

var topologicalSorting = function(numCourses, graph) {
    // 1. 初始化入度表
    const indegrees = new Map();
    for (let u of graph.keys()) {
        indegrees.set(u, 0);
    }

    // 计算每个节点的入度
    for (let u of graph.keys()) {
        for (let v of graph.get(u)) {
            indegrees.set(v, indegrees.get(v) + 1);
        }
    }

    // 2. 初始化队列，存储所有入度为0的节点
    const que = [];
    for (let [node, indegree] of indegrees.entries()) {
        if (indegree === 0) que.push(node);
    }

    // 3. 拓扑排序的过程
    while (que.length) {
        const u = que.pop(); // 从队列中取出一个节点（入度为0）
        numCourses -= 1; // 访问一个节点，课程数量减 1
        for (let v of graph.get(u)) {
            indegrees.set(v, indegrees.get(v) - 1); // 该节点的所有邻居节点入度减1
            if (indegrees.get(v) === 0) que.push(v); // 如果入度为 0，则将该节点加入队列
        }
    }

    // 4. 检查是否可以完成所有课程
    return numCourses === 0;
};
```
```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = dict()
        for i in range(numCourses):
            graph[i] = []  # 初始化图中的每个节点为空列表
        
        # 每个课程 u 指向所有依赖它的课程 v，即 u -> v
        # 这种邻接表的构建方式便于之后在拓扑排序中，从某个课程 u 出发，找到所有依赖 u 的课程 v，进而更新这些依赖课程的状态，例如入度表的更新
        for v, u in prerequisites:
            graph[u].append(v)  # 构建邻接表表示的图

        return self.topologicalSorting(numCourses, graph)
    
    def topologicalSorting(self, numCourses, graph):
        indegrees = {u: 0 for u in graph}  # 初始化每个节点的入度
        for u in graph:
            for v in graph[u]:
                indegrees[v] += 1  # 计算每个节点的入度
        
        # 使用双端队列存储所有入度为0的节点
        S = collections.deque([u for u in indegrees if indegrees[u] == 0])

        # 拓扑排序的过程
        while S:
            u = S.pop()  # 从队列中取出一个节点（入度为0）
            numCourses -= 1  # 减少未完成的课程数量
            for v in graph[u]:
                indegrees[v] -= 1  # 将该节点的所有邻居节点入度减1
                if indegrees[v] == 0:  # 如果邻居节点入度为0，则加入队列
                    S.append(v)
        
        # 如果所有课程都被处理完，返回True，否则返回False
        if numCourses == 0:
            return True
            
        return False
```

- 时间复杂度：`O(n + m)`，`n` 为课程数，`m` 为先修课程的要求数
- 空间复杂度：`O(n + m)`