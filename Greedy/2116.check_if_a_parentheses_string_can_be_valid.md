# 2116.Check if a Parentheses String Can Be Valid

## LeetCode 题目链接

[2116.判断一个括号字符串是否有效](https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/)

## 题目大意

一个括号字符串是只由 `'('` 和 `')'` 组成的 非空 字符串。如果一个字符串满足下面 任意 一个条件，那么它就是有效的：
- 字符串为 `()`
- 它可以表示为 `AB`（`A` 与 `B` 连接），其中 `A` 和 `B` 都是有效括号字符串
- 它可以表示为 `(A)`，其中 `A` 是一个有效括号字符串
  
给你一个括号字符串 `s` 和一个字符串 `locked`，两者长度都为 `n`。`locked` 是一个二进制字符串，只包含 `'0'` 和 `'1'`。对于 `locked` 中 每一个 下标 `i`：
- 如果 `locked[i]` 是 `'1'`，你 不能 改变 `s[i]` 
- 如果 `locked[i]` 是 `'0'`，你 可以 将 `s[i]` 变为 `'('` 或者 `')'` 
  
如果你可以将 `s` 变为有效括号字符串，请你返回 `true`，否则返回 `false` 

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9o003txdpb.webp)

限制:
- n == s.length == locked.length
- 1 <= n <= 10^5
- s[i] is either '(' or ')'.
- locked[i] is either '0' or '1'.

## 解题

不知道该怎么改 `locked[i] == '0'` 的字符，但使用贪心策略，维护一个区间 `[low, high]` 表示在当前位置可能拥有的未闭合的左括号 `(` 数量范围：
- `low`：最少能有多少个未闭合的左括号 `(`
- `high`：最多能有多少个未闭合的左括号 `(`

> 为什么用区间 `[low, high]`？
> - 解锁的位置 `locked[i] == '0'` 可变成 `'('` 或 `')'` → 不确定
> - 所以维护一个动态变化的“可能的范围”
> 如果这个区间一直合法，即：`low ≥ 0，high ≥ 0`，最终如果 `low == 0`，说明可能存在一种方式使所有括号匹配成功

> 为什么计算的是“左括号”的数量？维护的是当前还没有被闭合的左括号数量，因为判断括号是否合法的核心就是看是否：
> - 所有 `'('` 最终都有与之匹配的 `')'`
> - 且顺序合理（不能有 `')'` 没有前面的 `'('` 来闭合）
> 所以每看到一个 `'('`，就相当于“开启”了一个括号，它必须被匹配；每看到一个 `')'`，就相当于“闭合”一个左括号
>
> 如果在某一步：
> - 出现未被匹配的 `')'`（即没有可用的左括号），说明括号结构不合法
> - 这就是为什么从左到右遍历时，核心是维护未闭合左括号的数量区间

遍历时根据字符是固定的还是可变的，更新 `low` 和 `high` 的区间范围

更新规则：
- 对于每个位置 `i`：
  - 如果 `locked[i] == '1'`（不可变）：
    - 如果 `s[i] == '('`，则 `low += 1`, `high += 1`
    - 如果 `s[i] == ')'`，则 `low -= 1`, `high -= 1`
  - 如果 `locked[i] == '0'`（可以变）：
    - 可假设最坏是 `')'`，最好是 '`('`
    - 所以：`low -= 1`, `high += 1`
- 然后保证：
  - `high >= 0`（表示最多能有多少左括号）
  - `low = max(low, 0)`（最少不能小于 `0`，否则提前不合法）

最终判断：如果最后 `low == 0`，说明至少能找到一种修改方式使得括号合法

```js
var canBeValid = function(s, locked) {
    let n = s.length;
    if (n % 2 !== 0) return false;

    let low = 0, high = 0;

    for (let i = 0; i < n; i++) {
        if (locked[i] === '1') {
            if (s[i] === '(') {
                low += 1;
                high += 1;
            } else {
                low -= 1;
                high -= 1;
            }
        } else {
            // unlocked, can be '(' or ')'
            low -= 1;
            high += 1;
        }

        if (high < 0) return false;
        low = Math.max(low, 0);
    }

    return low === 0;
};
```
```python
class Solution:
    def canBeValid(self, s: str, locked: str) -> bool:
        # 奇数长度一定不可能是合法括号序列（合法括号必须成对出现）
        if len(s) % 2 == 1:
            return False

        # 初始化未闭合左括号的最小值和最大值都为 0
        low = high = 0
        for i in range(len(s)):
            # locked[i] == '1'（不能改）
            if locked[i] == '1':
                # 如果是 '('，有一个新的未闭合左括号，区间整体右移 +1
                if s[i] == '(':
                    low += 1
                    high += 1
                else:  # 如果是 ')'，尝试关闭一个未闭合括号，区间整体左移 -1
                    low -= 1
                    high -= 1
            else: # locked[i] == '0'（可以自由改）
                # 最“坏”情况：s[i] 是 ')' → low -= 1
                # 最“好”情况：s[i] 是 '(' → high += 1
                # 这表示可能少一个左括号，也可能多一个
                low -= 1
                high += 1

            # 如果最大可能值都 < 0，说明右括号过多，已无法配对 → 提前失败
            # 在每一步：
            # - high 表示当前最多可能有多少个未闭合的 '('
            # - 如果 high < 0，说明即使“尽可能地”把所有可变字符当作 '(' 处理，都没有足够的左括号与 ')' 配对
            # 换句话说：如果最多都配不上右括号，说明一定非法
            # 所以这步是剪枝，防止继续处理已经不可能合法的字符串
            if high < 0:
                return False

            # 修正下界（不能为负），最少不能小于 0（即不能有负数个左括号）
            # low 是当前可能最少的未闭合 '(' 数量。但它不能小于 0，因为不能“预支”未来的左括号
            # 想象在某个位置有 low = -2，这表示当前右括号已超过左括号了两次，意味着当前括号结构已经乱了，除非后续有足够的 '(' 去纠正
            # 但这是不合理的，因为：
            # - 如果前面已经出现了未匹配的 ')'，合法性就已经被破坏，不能靠将来“倒着改”来修复
            # - 所以通过 low = max(low, 0) 来限制它不能为负数，等价于：“我们不能允许有右括号比左括号多的历史发生”
            low = max(low, 0)

        # 遍历结束后：如果最终 low == 0，说明存在一种合理方式使所有括号匹配成功
        # 因为：
        # - low 是最小可能未闭合左括号数，如果它为 0，说明一定存在一种修改方式，使得所有括号都成对闭合（合法）
        # - 如果 low > 0，说明无论怎么修改，都会剩下多余的 '('，无法闭合 → 不合法
        return low == 0
```

- 时间复杂度：`O(n)`，其中 `n` 为 `s` 的长度。即为遍历字符串维护 `low` 和 `high` 并判断 `s` 能否变为有效字符串的时间复杂度
- 空间复杂度：`O(1)`